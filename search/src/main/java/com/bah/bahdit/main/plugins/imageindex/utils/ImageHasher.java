/**
 * Copyright 2012 Booz Allen Hamilton. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  Booz Allen Hamilton licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.bah.bahdit.main.plugins.imageindex.utils;

import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;

import javax.imageio.ImageIO;

/**
 * This class is used to generate a hashtag from either an image, file or
 * string. The hash is generated by resizing the image to the given dimensions
 * (best results are dimensions that are a multiple of 4). Then each individual
 * pixel's brightness is compared to the average, generating a BigInteger which
 * is converted into a hexadecimal string.
 * 
 * 
 */
public class ImageHasher {

	// Width and height of resized image (multiplied they result in number of
	// bits for the hash)
	private static final int RESIZE_WIDTH = 8;
	private static final int RESIZE_HEIGHT = 8;

	public static String hash(Object obj) throws MalformedURLException,
			IOException {

		BufferedImage img = null;

		if (obj instanceof String)
			img = ImageIO.read(new URL((String) obj));

		else if (obj instanceof File)
			img = ImageIO.read((File) obj);

		return hash(img);
	}

	private static String hash(BufferedImage img) throws IOException {

		// Resize the image
		BufferedImage resized = normalizeSize(img);

		// Arrays to store pixel data
		int[] brightnessValues = new int[RESIZE_WIDTH * RESIZE_HEIGHT];
		int[] rgbVals = new int[RESIZE_WIDTH * RESIZE_HEIGHT];

		// Store pixel data into rgbVals
		resized.getRGB(0, 0, RESIZE_WIDTH, RESIZE_HEIGHT, rgbVals, 0,
				RESIZE_WIDTH);

		int index = 0;
		for (int colorVal : rgbVals) {
			// Seperate by colors
			int maxByte = 0xff;
			int red = (colorVal >> 16) & maxByte;
			int green = (colorVal >> 8) & maxByte;
			int blue = (colorVal) & maxByte;

			// Calculate the brightness of each pixel
			int brightnessValue = (int) Math.floor(0.2126 * red + 0.7152
					* green + 0.0722 * blue);

			brightnessValues[index] = brightnessValue;
			index++;
		}

		// Calculate the average
		double average = 0;
		for (int b : brightnessValues) {
			average += b;
		}
		average = (long) Math.ceil(average / (RESIZE_WIDTH * RESIZE_HEIGHT));

		String binaryString = "";

		for (int i = 0; i < brightnessValues.length; i++) {
			if (brightnessValues[i] > average) {
				// Add 2^i if the pixel is above average brightness
				binaryString = "1" + binaryString;
			} else {
				binaryString = "0" + binaryString;
			}
		}


		return binaryString;
	}

	private static BufferedImage normalizeSize(BufferedImage img) {
		BufferedImage resizedImage;

		try {
			// Create a buffered image with img's type if possible
			resizedImage = new BufferedImage(RESIZE_WIDTH, RESIZE_HEIGHT,
					img.getType());
		} catch (Exception e) {
			// Default to ABGR if there is an error
			resizedImage = new BufferedImage(RESIZE_WIDTH, RESIZE_HEIGHT,
					BufferedImage.TYPE_4BYTE_ABGR);
		}

		// Resize with Graphics2D using Bicubic algorithm
		Graphics2D g = resizedImage.createGraphics();
		g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,
				RenderingHints.VALUE_INTERPOLATION_BICUBIC);

		// Draw img to the resized image
		g.drawImage(img, 0, 0, RESIZE_WIDTH, RESIZE_HEIGHT, null);
		g.dispose();

		return resizedImage;
	}
}
